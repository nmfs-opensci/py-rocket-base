[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "py-rocket-base documentation",
    "section": "",
    "text": "Introduction\nThe py-rocket-base image is a base image for JupyterHubs with Jupyter Lab, RStudio, Desktop, and VSCode UIs. What makes py-rocket-base unique, is that the RStudio UI (via /rstudio) is a R and RStudio environment installed with Rocker installation scripts1. Thus all the Rocker design choices and R/RStudio environment choices are in that UI. Properly setting up environments to work properly with spatial libraries and HPC libraries is tricky. py-rocket-base solves this problem (and the associated maintenance of installation scripts) by using Rocker installation scripts.\nThe base image has the following support:",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#using-the-image",
    "href": "index.html#using-the-image",
    "title": "py-rocket-base documentation",
    "section": "Using the image",
    "text": "Using the image\nInclude a Dockerfile in your repository with the following from line:\nFROM ghcr.io/nmfs-opensci/py-rocket-base:latest\nFor simple extensions of py-rocket-base, this is the only line you need in the Dockerfile. py-rocket-base has ONBUILD statements that detect configuration files with the names: environment.yml, install.R, apt.txt, postBuild, start, and Desktop (directory). If those files are present, it triggers specific installation behavior. You can also add lines directory to the Dockerfile. See the documentation on using the base image.\nThis work is related to the work on the NMFS Open Science docker stack.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "py-rocket-base documentation",
    "section": "",
    "text": "See the Developer section other approaches for installing R/RStudio and the design goals for py-rocket-base.↩︎",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "customizing.html",
    "href": "customizing.html",
    "title": "1  Using py-rocket-base",
    "section": "",
    "text": "1.1 File structure\nOnly Dockerfile is required. The rest are optional.\nRead configuration_files to learn about apt.txt, environment.yml, install.R, postBuild, and start. Read Desktop to learn about the Desktop folder and files for applications.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Using py-rocket-base</span>"
    ]
  },
  {
    "objectID": "customizing.html#file-structure",
    "href": "customizing.html#file-structure",
    "title": "1  Using py-rocket-base",
    "section": "",
    "text": "your-repo/\n├── Dockerfile\n├── apt.txt\n├── environment.yml\n├── install.R\n├── postBuild\n├── start\n├── Desktop/\n│   ├── qgis.desktop\n│   ├── qgis.xml\n│   └── qgis.png",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Using py-rocket-base</span>"
    ]
  },
  {
    "objectID": "customizing.html#examples",
    "href": "customizing.html#examples",
    "title": "1  Using py-rocket-base",
    "section": "1.2 Examples",
    "text": "1.2 Examples\n\n1.2.1 Add some Python packages\nYou want to add some Python packages to the conda notebook environment.\nyour-repo/\n├── Dockerfile\n├── environment.yml\nDockerfile\nFROM ghcr.io/nmfs-opensci/py-rocket-base:latest\nenvironment.yml\nname: optional\nchannels:\n  - conda-forge\ndependencies:\n  - cmocean\n  - numpy\n\n\n1.2.2 Add R packages\nAdd an R script to install packages. Important: packages that have linux dependencies (e.g. all the spatial packages depend on GDAL) will not work if you use install.packages(). GDAL will not be installed.\nyour-repo/\n├── Dockerfile\n├── install.R\nDockerfile\nFROM ghcr.io/nmfs-opensci/py-rocket-base:latest\ninstall.R\n# to match rocker/verse:4.4 used in py-rocker-base\n# look up the date that the Rocker image was created and put that\nrepo &lt;- \"https://p3m.dev/cran/__linux__/jammy/2024-05-13\"\nlist.of.packages &lt;- c(\"ncdf4\", \"httr\", \"plyr\", \"lubridate\")\ninstall.packages(list.of.packages, repos=repo)\n\n\n1.2.3 Add R geospatial packages\nGeospatial packages require some linux packages. To get this working in your Docker image add this to your Docker file:\nDockerfile\nFROM ghcr.io/nmfs-opensci/py-rocket-base:latest\n\nUSER root\nRUN /rocker_scripts/install_geospatial.sh\nUSER ${NB_USER} \nYou have access to all the rocker_scripts and you can run these similar to the line above.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Using py-rocket-base</span>"
    ]
  },
  {
    "objectID": "configuration_files.html",
    "href": "configuration_files.html",
    "title": "2  Configuration files",
    "section": "",
    "text": "2.1 environment.yml\nThis is a standard format. You can add version pinning.\nenvironment.yml",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Configuration files</span>"
    ]
  },
  {
    "objectID": "configuration_files.html#environment.yml",
    "href": "configuration_files.html#environment.yml",
    "title": "2  Configuration files",
    "section": "",
    "text": "name: optional\nchannels:\n  - conda-forge\ndependencies:\n  - cmocean\n  - numpy",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Configuration files</span>"
    ]
  },
  {
    "objectID": "configuration_files.html#install.r",
    "href": "configuration_files.html#install.r",
    "title": "2  Configuration files",
    "section": "2.2 install.R",
    "text": "2.2 install.R\ninstall.R example\n# to match rocker/verse:4.4 used in py-rocker-base\n# look up the date that the Rocker image was created and put that\nrepo &lt;- \"https://p3m.dev/cran/__linux__/jammy/2024-05-13\"\nlist.of.packages &lt;- c(\"ncdf4\", \"httr\", \"plyr\", \"lubridate\")\ninstall.packages(list.of.packages, repos=repo)\n\n2.2.1 Add R geospatial packages\nGeospatial packages require some linux packages. To get this working in your docker image add this to your Docker file:\nFROM ghcr.io/nmfs-opensci/py-rocket-base:latest\n\nUSER root\nRUN /rocker_scripts/install_geospatial.sh\nUSER ${NB_USER}",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Configuration files</span>"
    ]
  },
  {
    "objectID": "configuration_files.html#apt.txt",
    "href": "configuration_files.html#apt.txt",
    "title": "2  Configuration files",
    "section": "2.3 apt.txt",
    "text": "2.3 apt.txt\nStandard format. You can have comments.\n# Some useful stuff\ntk-dev\n\n# Add some more\ncmocean",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Configuration files</span>"
    ]
  },
  {
    "objectID": "configuration_files.html#postbuild",
    "href": "configuration_files.html#postbuild",
    "title": "2  Configuration files",
    "section": "2.4 postBuild",
    "text": "2.4 postBuild\nThis is a script that will be run after all the other commands. This script is run as jovyan not as root. If you need commands run as root, you will need to add these to the Docker file.\npostBuild\n#!/bin/bash -l\nset -e\n\n&lt;bash commands&gt;",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Configuration files</span>"
    ]
  },
  {
    "objectID": "configuration_files.html#start",
    "href": "configuration_files.html#start",
    "title": "2  Configuration files",
    "section": "2.5 start",
    "text": "2.5 start\nstart bash code is run when the image starts. py-rocker-base has a start script at ${REPO_DIR}/start which loads the Desktop applications. If you change that start file, then the Desktop apps will not be loaded properly.\nBy default, if you include start in the child repo then that script is sourced within the ${REPO_DIR}/start script at the end. If you don’t want that behavior and want the whole start script replaced, then you will need to do that in your Docker file by copying your start file onto ${REPO_DIR}/start.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Configuration files</span>"
    ]
  },
  {
    "objectID": "configuration_files.html#desktop-applications",
    "href": "configuration_files.html#desktop-applications",
    "title": "2  Configuration files",
    "section": "2.6 Desktop applications",
    "text": "2.6 Desktop applications\nSee the chapter on Desktop applications.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Configuration files</span>"
    ]
  },
  {
    "objectID": "r-packages.html",
    "href": "r-packages.html",
    "title": "3  R packages",
    "section": "",
    "text": "To install extra R packages, use install.R. This is treated as an R script which is run. For example, you can have a script like\ninstall.R\nrepo &lt;- \"https://p3m.dev/cran/__linux__/jammy/2024-05-13\"\nlist.of.packages &lt;- c(\"ggplot2\",\"remotes\")\ninstall.packages(list.of.packages, repos=repo)\nremotes::install_github(\"hadley/httr@v0.4\")\n\n3.0.1 Spatial libraries\nSome packages depend on linux packages. One example are spatial packages like sf which depend on GDAL. In this case\ninstall.packages(\"sf\")\nwill not work because it will not install the linux package dependencies.\nThere are a few ways to get around this.\n\nInstall the necessary linux packages via apt-get. This can be hard.\nInstall via via /rocker_scipts/install_geospatial.sh To do this include\nRUN /rocker_scipts/install_geospatial.sh\nin your Dockerfile.\nUse r2u which has Ubuntu binaries with all the dependencies included.\n\n\n\n3.0.2 Default CRAN repository\nThe default CRAN repository is set in ${R_HOME}/etc/Rprofile.site and the CRAN environmental variable to\nhttps://p3m.dev/cran/__linux__/jammy/latest\nTo set a different repo, edit ${R_HOME}/etc/Rprofile.site or specify the repo to use in install.packages() like so\nrepo &lt;- \"https://p3m.dev/cran/__linux__/jammy/2024-05-13\"\nlist.of.packages &lt;- c(\"maps\", \"mapdata\", \"RColorBrewer\")\ninstall.packages(list.of.packages, repos=repo)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R packages</span>"
    ]
  },
  {
    "objectID": "desktop.html",
    "href": "desktop.html",
    "title": "4  Desktop",
    "section": "",
    "text": "4.1 Adding an application in your child docker image",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Desktop</span>"
    ]
  },
  {
    "objectID": "desktop.html#adding-an-application-in-your-child-docker-image",
    "href": "desktop.html#adding-an-application-in-your-child-docker-image",
    "title": "4  Desktop",
    "section": "",
    "text": "4.1.1 Create the Desktop directory\nCreate the directory and add the .desktop and optional .png and .xml files.\nyour-repo/\n├── Dockerfile\n├── optional extra files\n├── Desktop/\n│   ├── qgis.desktop\n│   ├── qgis.xml\n│   └── qgis.png\n\n4.1.1.1 .desktop file\nThe .desktop file is a configuration file that describes how an application is launched. The required parts are Name, Exec and Type. MimeType specifies what types of files the application can use (optional).\ncdat.desktop\n[Desktop Entry]\nType=Application\nName=CWUtils\nGenericName=CoastWatch Data Analysis Tool\nIcon=/srv/repo/Desktop/cdat.png\nTryExec=cdat\nExec=cdat %F\nTerminal=false\nStartupNotify=false\nCategories=Qt;Education;Science;Geography;\nKeywords=map;globe;\n\n\n4.1.1.2 .xml\nYou can specify the mime types via xml.\n\n\n4.1.1.3 .png\nYou can include a png for the icon. py-rocket-base will place this in /srv/repo/Desktop/ so use a location like /srv/repo/Desktop/my.png for your png that you include in your Desktop folder.\n\n\n\n4.1.2 Install the application\nHow you install the application really varies. Here are 2 examples.\nQGIS\n\nadd qgis to environment.yml\nadd libgl1-mesa-glx to apt.txt\nadd the .desktop file to Desktop directory\n\nqgis.desktop\n# From: https://github.com/qgis/QGIS/blob/ltr-3_28/linux/org.qgis.qgis.desktop.in\n[Desktop Entry]\nType=Application\nName=QGIS Desktop\nGenericName=Geographic Information System\nIcon=/srv/conda/envs/notebook/share/qgis/images/icons/qgis-icon-512x512.png\nTryExec=qgis\nExec=qgis %F\nTerminal=false\nStartupNotify=false\nCategories=Qt;Education;Science;Geography;\nMimeType=application/x-qgis-project;application/x-qgis-project-container;application/x-qgis-layer-settings;application/x-qgis-layer-definition;application/x-qgis-composer-template;image/tiff;image/jpeg;image/jp2;application/x-raster-aig;application/x-raster-ecw;application/x-raster-mrsid;application/x-mapinfo-mif;application/x-esri-shape;application/vnd.google-earth.kml+xml;application/vnd.google-earth.kmz;application/geopackage+sqlite3;\nKeywords=map;globe;postgis;wms;wfs;ogc;osgeo;\nStartupWMClass=QGIS3\nCoastWatch Utilities\nAdd this to the docker file to install\nUSER root\n# Install cwutils\nRUN cd /tmp && \\\n    wget https://www.star.nesdis.noaa.gov/socd/coastwatch/cwf/cwutils-4_0_0_198-linux-x86_64.tar.gz && \\\n    tar -zxf cwutils-4_0_0_198-linux-x86_64.tar.gz && \\\n    rm -rf cwutils-4_0_0_198-linux-x86_64.tar.gz\nENV PATH=${PATH}:/tmp/cwutils_4.0.0.198/bin\nENV MANPATH=${MANPATH}:/tmp/cwutils_4.0.0.198/doc/man\nENV INSTALL4J ADD VM PARAMS=-Dsun.java2d.uiScale=2.0\nUSER ${NB_USER}\nAdd this cdat.desktop file to Desktop directory\n[Desktop Entry]\nType=Application\nName=CWUtils\nGenericName=CoastWatch Data Analysis Tool\nIcon=/srv/repo/Desktop/cdat.png\nTryExec=cdat\nExec=cdat %F\nTerminal=false\nStartupNotify=false\nCategories=Qt;Education;Science;Geography;\nKeywords=map;globe;\nAdd cdat.png icon to Desktop directory.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Desktop</span>"
    ]
  },
  {
    "objectID": "desktop.html#whats-happening",
    "href": "desktop.html#whats-happening",
    "title": "4  Desktop",
    "section": "4.2 What’s happening",
    "text": "4.2 What’s happening\nTo add new desktop applications, one needs to do the following. py-rocket-base does these steps automatically (via the start script) so that the user only has to put files into a Desktop directory in the docker build repo.\n\nInstall the application. See examples.\nAdd a .desktop file to ${HOME}/.local/share/applications/.\nTo have an icon on the Desktop, you create a folder Desktop in the ${HOME} and create a soft link to the .desktop files in ${HOME}/.local/share/applications/.\n\nSee this Medium article for a description.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Desktop</span>"
    ]
  },
  {
    "objectID": "tex.html",
    "href": "tex.html",
    "title": "5  Creating PDFs",
    "section": "",
    "text": "5.1 tlmgr",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Creating PDFs</span>"
    ]
  },
  {
    "objectID": "tex.html#tlmgr",
    "href": "tex.html#tlmgr",
    "title": "5  Creating PDFs",
    "section": "",
    "text": "Do not use apt-get to install texlive packages. This will turn off tlmgr (the TeX package manager). Instead use\n\ntlmgr install &lt;package&gt;\n\nRun tlmgr option to make sure tlmgr is working.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Creating PDFs</span>"
    ]
  },
  {
    "objectID": "tex.html#installing-packages",
    "href": "tex.html#installing-packages",
    "title": "5  Creating PDFs",
    "section": "5.2 Installing packages",
    "text": "5.2 Installing packages\nUnfortunately any packages you install will be in the /opt directory and this gets recreated every time you restart your server. So if you need a particular package you will need to keep installing it. Or create your own image based on py-rocket-base:\nDockerfile\nFROM ghcr.io/nmfs-opensci/py-rocket-base:latest\n\nRUN tlmgr install collection-latexrecommended && tlmgr clean --all",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Creating PDFs</span>"
    ]
  },
  {
    "objectID": "tex.html#rstudio-creating-pdfs-with-quarto-or-rmarkdown",
    "href": "tex.html#rstudio-creating-pdfs-with-quarto-or-rmarkdown",
    "title": "5  Creating PDFs",
    "section": "5.3 RStudio: Creating pdfs with Quarto or RMarkdown",
    "text": "5.3 RStudio: Creating pdfs with Quarto or RMarkdown\nKnit to PDF or format: pdf should work fine and packages will be installed on the fly. But the package installations will not persist and you will need to install them again after you restart the server.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Creating PDFs</span>"
    ]
  },
  {
    "objectID": "tex.html#jupyter-lab",
    "href": "tex.html#jupyter-lab",
    "title": "5  Creating PDFs",
    "section": "5.4 Jupyter Lab",
    "text": "5.4 Jupyter Lab\nMyst and Quarto are installed so this works:\nCreating pdfs from a Jupyter notebook: jupyter nbconvert --to pdf test.ipynb\nCreating pdfs from a Quarto notebook: quarto render --to pdf test.qmd\nPackages will not install on the fly and you will need to do tlmgr install packagename for any missing package errors you get.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Creating PDFs</span>"
    ]
  },
  {
    "objectID": "jupyter-config.html",
    "href": "jupyter-config.html",
    "title": "6  Customizing Jupyter",
    "section": "",
    "text": "If you want to customize some feature of the JupyterHub or JupyterLab, you can do this by passing in *.json or *.py configuration files. In py-rocket-base, these are in the jupyter_server_config.d and jupyter_notebook_config.d directories in the conda notebook environment. These directories contain the json that specifies the configurations:\n/srv/conda/envs/notebook/\n└── etc/\n    └── jupyter/\n        └── jupyter_server_config.d/\n            ├── security.json\n            ├── extensions.json\n            └── custom.json\n        └── jupyter_notebook_config.d/\n            └── custom.json\nIf you want to change these configurations, you need to either update the file with the configuration or add a new configuration file. You can add either .json or .py configurations files to the same directory.\nFor example, if you want to allow hidden files to be shown in the file browser in Jupyter Lab. Add\ncustom_jupyter_server_config.json\n{\n    \"ContentsManager\": {\n        \"allow_hidden\": true\n    }\n}\nand then copy this into jupyter_server_config.d and jupyter_notebook_config.d via code in the Dockerfile or in postBuild. We copy both to notebook server config and jupyter server config, because either can be used in the JupyterHub.\nDockerfile\nCOPY custom_jupyter_server_config.json custom_jupyter_server_config.json\nRUN cp custom_jupyter_server_config.json ${NB_PYTHON_PREFIX}/etc/jupyter/jupyter_server_config.d/ && \\\n    cp custom_jupyter_server_config.json ${NB_PYTHON_PREFIX}/etc/jupyter/jupyter_notebook_config.d/ && \\\n    rm custom_jupyter_server_config.json\nAlternatively, you can add a postBuild file to your repo and py-rocket-base will automatically run this when you image builds.\npostBuild\n#!/bin/bash -l\nset -euo pipefail\n\ncp custom_jupyter_server_config.json ${NB_PYTHON_PREFIX}/etc/jupyter/jupyter_server_config.d/\ncp custom_jupyter_server_config.json ${NB_PYTHON_PREFIX}/etc/jupyter/jupyter_notebook_config.d/",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Customizing Jupyter</span>"
    ]
  },
  {
    "objectID": "developers.html",
    "href": "developers.html",
    "title": "7  Developer notes",
    "section": "",
    "text": "7.1 Design\npy-rocket-base is inspired by repo2docker and the Pangeo Docker stack design. py-rocker-base is built using repo2docker (via repo2docker-action) and thus lets repo2docker make the choices regarding the environment design—things like how the conda environment is set-up and the base directory structure and permissions.\nThe Pangeo Docker stack does not use repo2docker, but mimics repo2docker’s environment design. The Pangeo base-image behaves similar to repo2docker in that using the base-image in the FROM line of a Dockerfile causes the build to look for files with the same names as repo2docker’s configuration files and then do the proper action with those files. This means that routine users do not need to know how to write Dockerfile code in order to extend the image with new packages or applications. py-rocker-base Docker image uses this Pangeo base-image design. It is based on ONBUILD commands in the Dockerfile that trigger actions only when the image is used in the FROM line of another Dockerfile.\nThere are many ways to install R and RStudio into an image designed for JupyterHubs The objective of py-rocker-base is not to install R and RStudio, per se, and there are other leaner and faster ways to install R/RStudio if that is your goal1. The objective of py-rocket-base is to create an JupyterHub image such when you click the RStudio button in the JupyterLab UI to enter the RStudio UI, you enter an environment that is the same as if you had used a Rocker image. If you are in the JupyterLab UI, the environment is the same as it you had used repo2docker (or Pangeo base-image) to create the environment.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Developer notes</span>"
    ]
  },
  {
    "objectID": "developers.html#design",
    "href": "developers.html#design",
    "title": "7  Developer notes",
    "section": "",
    "text": "See for example repo2docker-r and conda-r in binder-examples.↩︎",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Developer notes</span>"
    ]
  },
  {
    "objectID": "developers.html#documentation",
    "href": "developers.html#documentation",
    "title": "7  Developer notes",
    "section": "7.2 Documentation",
    "text": "7.2 Documentation\nTo build the documentation book, clone repo and then\ncd book\nquarto render .\nSet GitHub Pages to docs folder.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Developer notes</span>"
    ]
  },
  {
    "objectID": "developers.html#repo2docker",
    "href": "developers.html#repo2docker",
    "title": "7  Developer notes",
    "section": "7.3 repo2docker",
    "text": "7.3 repo2docker\nrepo2docker-action is creating the image and publishing to ghcr.io/nmfs-opensci/py-rocket-base (image hosting like dockerhub or quay.io).\nrepo2docker (a python package) sets up the structure of the base environment, e.g. installs mamba for package solving, sets up environment variables, installs linux packages, etc. It looks for specific files (like apt.txt, environment.yml, postBuild) in the build context (the repo that the Dockerfile is in) and takes the appropriate action. repo2docker-action also allows you to include appendix to add more commands to your Dockerfile.\nrepo2docker does a lot behind the scene and has some different behavior.\n\n7.3.1 COPY\nCOPY &lt;src&gt; &lt;dest&gt; does not work in appendix because repo2docker changes the build context. The files are in src not .. In appendix, you do not do lines like this\nCOPY file1 newlocation/file1\nto bring file1 into the build. Instead, the files are already in ${REPO_DIR}/. If you want to copy a file to a new location, run the following as root if jovyan does not have permission to write to newlocation.\nRUN cp ${REPO_DIR}/file1 newlocation/file1\n\n\n7.3.2 ENV and ARGS\nrepo2docker uses a number of ARGs in the build which you might expect to be in the image environment, for example ${NB_USER}. These need to be converted to ENV to be available to child builds.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Developer notes</span>"
    ]
  },
  {
    "objectID": "developers.html#rstudio",
    "href": "developers.html#rstudio",
    "title": "7  Developer notes",
    "section": "7.4 RStudio",
    "text": "7.4 RStudio\njupyter-rsession-proxy allows us to launch RStudio from Jupyter Lab, but the environment is different than the environment in Jupyter Lab.\n\n7.4.1 Environmental variables\n\nPATH is different. conda is not on the path.\nNone of the environmental variables in the docker file will be in the /rstudio environment. The start command affects \\lab and \\notebook but not \\rstudio.\nThe path in the terminal (in RStudio) can/is different than in the R console. Expect weird unexpected behavior because of this. If you type bash, then .bashrc is run and that will run conda init and that will add conda binaries to the path. Then really weird and unexpected things can happen.\n\nIf you need some environmental variable set, you will need to set those in $R_HOME/etc/Rprofile.site which is run when R starts.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Developer notes</span>"
    ]
  },
  {
    "objectID": "developers.html#basic-structure-of-py-rocket-base",
    "href": "developers.html#basic-structure-of-py-rocket-base",
    "title": "7  Developer notes",
    "section": "7.5 Basic structure of py-rocket-base",
    "text": "7.5 Basic structure of py-rocket-base\nThe py-rocket-base docker build has the following structure:\n# base image and environment\nrepo2docker sets this up\nrepo2docker-action sets the directory where the build files \n  are put to /srv/repo (via $REPO_DIR in GitHub Action)\n  and ownership is set to jovyan (via $NB_USER)\n  \n# environment.yml\nrepo2docker adds these packages to the conda notebook environment\n\n# start\nrepo2docker points the Docker image entrypoint (command run on start) to this file\n${REPO_DIR}/start\n\n# appendix\nrepo2docker-action adds the Docker commands here to the end of Dockerfile\nmost of the work in py-rocket-base is done here. appendix calls rocker.sh and install packages in apt2.txt\nEach file is described below.\n\n7.5.1 apt2.txt\nThis is not named apt.txt because these packages need to be installed after R is installed because the R scripts uninstall packages as part of cleanup. There are some packages that are required for Desktop (/desktop) to operate correctly. Packages needed for R and RStudio building (/rstudio) are installed via the rocker install scripts.\n\n\n7.5.2 environment.yml\nThese are added to the notebook conda environment and in py-rocket-base the basic packages needed for Jupyter Lab, RStudio and Desktop are added. Scientific packages are not added here. They will be added via child images that use py-rocket-base as the base image (in the FROM line).\n\n\n7.5.3 appendix\nThis a long file with many pieces. The pieces are explained below. Click on the number next to code to read about what that code block does.\n1USER root\n\n# repo2docker does not set this. This is the default env in repo2docker type images\n2ENV CONDA_ENV=notebook\n\n# Install R, RStudio via Rocker scripts\n3ENV R_VERSION=\"4.4.1\"\nENV R_DOCKERFILE=\"verse_${R_VERSION}\"\n# This is in the rocker script but will not run since ${NB_USER} already exists\n# Needed because rocker scripts set permissions based on the staff group\nRUN usermod -a -G staff \"${NB_USER}\"\nRUN PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin && \\\n  chmod +x ${REPO_DIR}/rocker.sh && \\\n  ${REPO_DIR}/rocker.sh\n\n4# Install linux packages after R installation since the R install scripts get rid of packages\n# The package_list part is reading the file and doing clean-up to just have the list of packages\nRUN package_list=$(grep -v '^\\s*#' ${REPO_DIR}/apt2.txt | grep -v '^\\s*$' | sed 's/\\r//g; s/#.*//; s/^[[:space:]]*//; s/[[:space:]]*$//' | awk '{$1=$1};1') && \\\n  apt-get update && \\\n  apt-get install --yes --no-install-recommends $package_list && \\\n  apt-get autoremove --purge && \\\n  apt-get clean && \\\n  rm -rf /var/lib/apt/lists/*\n  \n# Re-enable man pages disabled in Ubuntu 18 minimal image\n# https://wiki.ubuntu.com/Minimal\n5RUN yes | unminimize\n# NOTE: $NB_PYTHON_PREFIX is the same as $CONDA_PREFIX at run-time.\n# $CONDA_PREFIX isn't available in this context.\n# NOTE: Prepending ensures a working path; if $MANPATH was previously empty,\n# the trailing colon ensures that system paths are searched.\nENV MANPATH=\"${NB_PYTHON_PREFIX}/share/man:${MANPATH}\"\nRUN mandb\n\n# Add custom jupyter config. You can also put config.py files in the same place\n6COPY custom_jupyter_server_config.json ${NB_PYTHON_PREFIX}/etc/jupyter/jupyter_server_config.d/\nCOPY custom_jupyter_server_config.json ${NB_PYTHON_PREFIX}/etc/jupyter/jupyter_notebook_config.d/\n\n# Clean up extra files in ${REPO_DIR}\n7RUN rm -rf ${REPO_DIR}/book ${REPO_DIR}/docs\n\n###################\n# Set up behavior for child dockerfiles\n# Convert NB_USER to ENV (from ARG) so that it passes to the child dockerfile\n8ENV NB_USER=${NB_USER}\n\n9## ONBUILD section. These commands are run in child Dockerfiles. These are run right after the FROM image is loaded\n\n10ONBUILD USER ${NB_USER}\n\n# ${REPO_DIR} is owned by ${NB_USER}\n11ONBUILD COPY --chown=${NB_USER}:${NB_USER} . ${REPO_DIR}/childimage\n\n\n# Copy Desktop files into ${REPO_DIR}/Desktop if they exist. start will copy to Application dir and Desktop\n# Will not fail if Desktop dir exists but is empty\n13ONBUILD RUN echo \"Checking for 'Desktop directory'...\" \\\n        ; cd \"${REPO_DIR}/childimage/\" \\\n        ; if test -d Desktop ; then \\\n            mkdir -p \"${REPO_DIR}/Desktop\" && \\\n            [ \"$(ls -A Desktop 2&gt;/dev/null)\" ] && cp -r Desktop/* \"${REPO_DIR}/Desktop/\"; \\\n        fi\n\n# Install apt packages specified in a apt.txt file if it exists.\n# blank lines and comments are supported in apt.txt\n14ONBUILD USER root\nONBUILD RUN echo \"Checking for 'apt.txt'...\" \\\n        ; cd \"${REPO_DIR}/childimage/\" \\\n        ; if test -f \"apt.txt\" ; then \\\n        package_list=$(grep -v '^\\s*#' apt.txt | grep -v '^\\s*$' | sed 's/\\r//g; s/#.*//; s/^[[:space:]]*//; s/[[:space:]]*$//' | awk '{$1=$1};1') \\\n        && apt-get update --fix-missing &gt; /dev/null \\\n        && apt-get install --yes --no-install-recommends $package_list \\\n        && apt-get autoremove --purge \\\n        && apt-get clean \\\n        && rm -rf /var/lib/apt/lists/* \\\n        ; fi\n15ONBUILD USER ${NB_USER}\n\n# Add the conda environment\n# sometimes package solving will get rid of pip installed packages. Make sure jupyter-remote-desktop-proxy does not disappear\n16ONBUILD RUN echo \"Checking for 'conda-lock.yml' or 'environment.yml'...\" \\\n        ; cd \"${REPO_DIR}/childimage/\" \\\n        ; if test -f \"conda-lock.yml\" ; then echo \"Using conda-lock.yml\" & \\\n        conda-lock install --name ${CONDA_ENV} \\\n        && pip install --no-deps jupyter-remote-desktop-proxy \\\n        ; elif test -f \"environment.yml\" ; then echo \"Using environment.yml\" & \\\n        mamba env update --name ${CONDA_ENV} -f environment.yml  \\\n        && pip install --no-deps jupyter-remote-desktop-proxy \\\n        ; fi \\\n        && mamba clean -yaf \\\n        && find ${CONDA_DIR} -follow -type f -name '*.a' -delete \\\n        && find ${CONDA_DIR} -follow -type f -name '*.js.map' -delete \\\n        ; if ls ${NB_PYTHON_PREFIX}/lib/python*/site-packages/bokeh/server/static &gt; /dev/null 2&gt;&1; then \\\n        find ${NB_PYTHON_PREFIX}/lib/python*/site-packages/bokeh/server/static -follow -type f -name '*.js' ! -name '*.min.js' -delete \\\n        ; fi\n\n# If a requirements.txt file exists, use pip to install packages\n# listed there. We don't want to save cached wheels in the image\n# to avoid wasting space.\n17ONBUILD RUN echo \"Checking for pip 'requirements.txt'...\" \\\n        ; cd \"${REPO_DIR}/childimage/\" \\\n        ; if test -f \"requirements.txt\" ; then \\\n        ${NB_PYTHON_PREFIX}/bin/pip install --no-cache -r requirements.txt \\\n        ; fi\n\n# Add the r packages\n18ONBUILD RUN echo \"Checking for 'install.R\" \\\n        ; cd \"${REPO_DIR}/childimage/\" \\\n        ; if test -f \"install.R\" ; then echo \"Using install.R\" & \\\n        Rscript install.R \\\n        ; fi\n\n# If a start file exists, put that under ${REPO_DIR}/childimage/start. \n# This is sourced in ${REPO_DIR}/start\n19ONBUILD RUN echo \"Checking for 'start'...\" \\\n        ; cd \"${REPO_DIR}/childimage/\" \\\n        ; if test -f \"start\" ; then \\\n        chmod +x start \\\n        ; fi\n\n# If a postBuild file exists, run it!\n# After it's done, we try to remove any possible cruft commands there\n# left behind under $HOME - particularly stuff that jupyterlab extensions\n# leave behind.\n20ONBUILD RUN echo \"Checking for 'postBuild'...\" \\\n        ; cd \"${REPO_DIR}/childimage/\" \\\n        ; if test -f \"postBuild\" ; then \\\n        chmod +x postBuild \\\n        && ./postBuild \\\n        && rm -rf /tmp/* \\\n        && rm -rf ${HOME}/.cache ${HOME}/.npm ${HOME}/.yarn \\\n        && rm -rf ${NB_PYTHON_PREFIX}/share/jupyter/lab/staging \\\n        && find ${CONDA_DIR} -follow -type f -name '*.a' -delete \\\n        && find ${CONDA_DIR} -follow -type f -name '*.js.map' -delete \\\n        ; fi\n\n## End ONBUILD section for child images\n################################\n\n# Revert to default user and home as pwd\n21USER ${NB_USER}\nWORKDIR ${HOME}\n\n1\n\nSome commands need to be run as root, such as installing linux packages with apt-get\n\n2\n\nrepo2docker does not set this environment variable and it is useful for child builds\n\n3\n\nThis section runs the script rocker.sh which installs R and RStudio using rocker scripts.\n\n4\n\nThe rocker scripts build R from source and as part of clean up in the script, linux packages are removed that are not needed. repo2docker installs the packages in apt.txt automatically before the code in appendix thus the needed linux packages (which include packages for desktop) are put in apt2.txt (which repo2docker will not detect) and are installed separately here. The grep -v etc code is processing apt2.txt and removing comments and blank lines.\n\n5\n\nUbuntu does not have man pages installed by default. These lines activate man so users have the common help files.\n\n6\n\nThis is some custom jupyter config to allow hidden files to be listed in the folder browser.\n\n7\n\nbook and docs are the documentation files and are not needed in the image.\n\n8\n\nThe NB_USER environmental variable is not exported by repo2docker (it is an argument confined to the parent build) but is very useful for child builds. So it is converted to an environmental variable.\n\n9\n\nThis next section is a series of ONBUILD commands. These are only run if py-rocker-base is used in the FROM line in a child docker file.\n\n10\n\nSet the user to NB_USER. Not strictly necessary but helps ensure that we don’t accidentally create files that jovyan (NB_USER) cannot access.\n\n11\n\nCopy the child build context (files with the Docker file) into ${REPO_DIR}. Make sure that jovyan owns the directory. Note, jovyan owns ${REPO_DIR} (this is set by repo2docker).\n\n13\n\nThe Desktop files are put in a directory called Desktop. Copy them into ${REPO_DIR}/Desktop. The start script will copy these into the correct location for the Desktop server.\n\n14\n\nIf apt.txt is present, then install the packages. The code processes any comments or blank lines in apt.txt. This must be run as root so we switch to root to install.\n\n15\n\nSwitch back to jovyan so we don’t accidentally make files as belonging to root.\n\n16\n\nIf environment.yml is present, install these into the conda environment and do some clean-up. Sometimes package solving will get rid of pip installed packages. We need to make sure that jupyter-remote-desktop-proxy does not disappear.\n\n17\n\nIf requirements.txt is present, install with pip and do some clean-up.\n\n18\n\ninstall.R is an R script where the user can specify how to install packages or run any other R code.\n\n19\n\nstart is run in the ${REPO_DIR}/start command in a subshell. The ${REPO_DIR}/start command cannot be replaced since it contains code to move the Desktop files into the correct place.\n\n20\n\npostBuild is a script. If present, run it and then do some clean-up. It is common to use postBuild to apply extensions or install packages that cannot be installed with apt.\n\n21\n\nThe parent docker build completes by setting the user to jovyan and the working directory to ${HOME}. Within a JupyterHub deployment, ${HOME} will often be re-mapped to the user persistent memory so it is important not to write anything that needs to be persistent to ${HOME}, for example configuration. You can do this in the start script since that runs after the user directory is mapped or you can put configuration files in some place other than ${HOME}.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Developer notes</span>"
    ]
  },
  {
    "objectID": "developers.html#rocker.sh",
    "href": "developers.html#rocker.sh",
    "title": "7  Developer notes",
    "section": "7.6 rocker.sh",
    "text": "7.6 rocker.sh\nThis script will copy in the rocker scripts from rocker-versioned2 into ${REPO_DIR} to install things. It will read in one of the rocker docker files using R_DOCKERFILE defined in the appendix file (which is inserted into the main docker file). Variables defined here will only be available in this script. Click on the numbers in the script to learn what each section is doing.\n#!/bin/bash\nset -e\n\n# Copy in the rocker files. Work in ${REPO_DIR} to make sure I don't clobber anything\ncd ${REPO_DIR}\nwget https://github.com/rocker-org/rocker-versioned2/archive/refs/tags/R${R_VERSION}.tar.gz\ntar zxvf R${R_VERSION}.tar.gz && \\\nmv rocker-versioned2-R${R_VERSION}/scripts /rocker_scripts && \\\nROCKER_DOCKERFILE_NAME=\"${R_DOCKERFILE}.Dockerfile\"\nmv rocker-versioned2-R${R_VERSION}/dockerfiles/${ROCKER_DOCKERFILE_NAME}  /rocker_scripts/original.Dockerfile && \\\nrm R${R_VERSION}.tar.gz && \\\nrm -rf rocker-versioned2-R${R_VERSION}\n\ncd /\n# Read the Dockerfile and process each line\nwhile IFS= read -r line; do\n    # Check if the line starts with ENV or RUN\n    if [[ \"$line\" == ENV* ]]; then\n        # Assign variable\n        var_assignment=$(echo \"$line\" | sed 's/^ENV //g')\n        # Replace ENV DEFAULT_USER=\"jovyan\"\n        if [[ \"$var_assignment\" == DEFAULT_USER* ]]; then\n            var_assignment=\"DEFAULT_USER=${NB_USER}\"\n        fi\n        # Run this way eval \"export ...\" otherwise the \" will get turned to %22\n        eval \"export $var_assignment\"\n        # Write the exported variable to env.txt\n        echo \"export $var_assignment\" &gt;&gt; ${REPO_DIR}/env.txt\n    elif [[ \"$line\" == RUN* ]]; then\n        # Run the command from the RUN line\n        cmd=$(echo \"$line\" | sed 's/^RUN //g')\n        echo \"Executing: $cmd\"\n        eval \"$cmd\" # || echo ${cmd}\" encountered an error, but continuing...\"\n    fi\ndone &lt; /rocker_scripts/original.Dockerfile\n\n# Install extra tex packages that are not installed by default\nif command -v tlmgr &&gt; /dev/null; then\n    echo \"Installing texlive collection-latexrecommended...\"\n    tlmgr install collection-latexrecommended\n    tlmgr install pdfcol tcolorbox eurosym upquote adjustbox titling enumitem ulem soul rsfs\nfi\n\n1\n\nThe rocker-versioned2 repository for a particular R version is copied into {REPO_DIR} and unzipped. R_VERSION is defined in appendix.\n\n2\n\nThe unzipped directory will be named rocker-versioned2-R${R_VERSION}. We move the scripts directory to /rocker_scripts (base level) because the rocker scripts expect the scripts to be there.\n\n3\n\nR_DOCKERFILE is defined as verse_${R_VERSION}. The docker file we will process (find ENV and RUN lines) is called ROCKER_DOCKERFILE_NAME in the rocker files. We move this to /rocker_scripts/original.Dockerfile so we can refer to it later.\n\n4\n\nClean up the rocker directories that we no longer need.\n\n5\n\ncd to the base level where /rocker_scripts is.\n\n6\n\nThe big while loop is processing /rocker_scripts/original.Dockerfile. The code is using piping &gt; and the input file and pipe is specified at the end of the while loop code.\n\n7\n\nThis looks if the line starts with ENV and if it does, it strips off ENV and stores the variable assigment statement to $var_assignment.\n\n8\n\nThe rocker docker files do not use the NB_USER environmental variable (defined in appendix). If the ENV line is defining the default user, we need to change that assignment to the variable NB_USER. This part is specific to the rocker docker files.\n\n9\n\nWe need to export any variables (ENV) found in the docker file so it is available to the scripts that will run in the RUN statements. We need to export the variables as done here (with eval and export) otherwise they don’t make it to the child scripts about to be run. Getting variables to be exported to child scripts being called by a parent script is tricky and this line required a lot of testing and debugging to get variables exported properly.\n\n10\n\nThe export line will only make the variable available to the child scripts. We also want them available in the final image. To do that, we write them to a file that we will source from the docker file. Scripts are run in an ephemeral subshell during docker builds so we cannot define the variable here.\n\n11\n\nIf the docker file line starts with RUN then run the command. This command should be a rocker script because that is how rocker docker files are organized. See an example rocker docker file.\n\n12\n\nHere the input file for the while loop is specified.\n\n13\n\nThe rocker install_texlive.sh script (which is part of verse) will provide a basic texlive installation. Here a few more packages are added so that the user is able to run vanilla Quarto to PDF and Myst to PDF. See the chapter on texlive.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Developer notes</span>"
    ]
  },
  {
    "objectID": "developers.html#start",
    "href": "developers.html#start",
    "title": "7  Developer notes",
    "section": "7.7 start",
    "text": "7.7 start\nWithin a JupyterHub, the user home directory $HOME is typically re-mapped to the user persistent home directory. That means that the image build process cannot put things into $HOME, they would just be lost when $HOME is re-mapped. If a process needs to have something in the home directory, e.g. in some local user configuration, this must be done in the start script. The repo2docker docker image specifies that the start script is ${REPO_DIR}/start.\nFor py-rocket-base, the start script is used to move the Desktop files (*.desktop) to where the Desktop server expects them, which is ${HOME}/.local/share/applications/ and ${HOME}/Desktop. Any *.desktop files found there will appear as clickable icons in \\desktop. This must be done in start, since the files need to be put in ${HOME} which not available until after the server starts.\n#!/bin/bash\nset -euo pipefail\n\n# Start - Set any environment variables here\n# These are inherited by all processes, *except* RStudio\n# USE export &lt;parname&gt;=value\n# Tell applications where to open desktop apps - this allows notebooks to pop open GUIs\nexport DISPLAY=\":1.0\"\n# source this file to get the variables defined in the rocker Dockerfile\nsource ${REPO_DIR}/env.txt\n# End - Set any environment variables here\n\n# The for loops will fail if they return null (no files). Set shell option nullglob\nshopt -s nullglob\n\n# Add any .desktop files to the application database and desktop. This is done\n# at startup-time because it's expected that a remote filesystem will be\n# mounted at $HOME, which would overwrite the data if it was created at\n# build-time.\nAPPLICATIONS_DIR=\"${HOME}/.local/share/applications\"\nDESKTOP_DIR=\"${HOME}/Desktop\"\n# Remove DESKTOP_DIR if it exists to avoid leftover files\nif [ -d \"${DESKTOP_DIR}\" ]; then\n    rm -rf \"${DESKTOP_DIR}\"\nfi\nmkdir -p \"${APPLICATIONS_DIR}\"\nmkdir -p \"${DESKTOP_DIR}\"\nfor desktop_file_path in ${REPO_DIR}/Desktop/*.desktop; do\n    cp \"${desktop_file_path}\" \"${APPLICATIONS_DIR}/.\"\n\n    # Symlink application to desktop and set execute permission so xfce (desktop) doesn't complain\n    desktop_file_name=\"$(basename ${desktop_file_path})\"\n    # Set execute permissions on the copied .desktop file\n    chmod +x \"${APPLICATIONS_DIR}/${desktop_file_name}\"\n    ln -sf \"${APPLICATIONS_DIR}/${desktop_file_name}\" \"${DESKTOP_DIR}/${desktop_file_name}\"\ndone\nupdate-desktop-database \"${APPLICATIONS_DIR}\"\n\n# Add MIME Type data from XML files  to the MIME database.\nMIME_DIR=\"${HOME}/.local/share/mime\"\nMIME_PACKAGES_DIR=\"${MIME_DIR}/packages\"\nmkdir -p \"${MIME_PACKAGES_DIR}\"\nfor mime_file_path in ${REPO_DIR}/Desktop/*.xml; do\n    cp \"${mime_file_path}\" \"${MIME_PACKAGES_DIR}/.\"\ndone\nupdate-mime-database \"${MIME_DIR}\"\n\n# Run child start in a subshell to contain its environment\n[ -f ${REPO_DIR}/childimage/start ] && ( source ${REPO_DIR}/childimage/start )\n\nexec \"$@\"",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Developer notes</span>"
    ]
  }
]