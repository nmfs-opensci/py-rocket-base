[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "py-rocket-base documentation",
    "section": "",
    "text": "Introduction\nghcr.io/nmfs-opensci/py-rocket-base:latest\nThe base image has the following support:",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#using-the-image",
    "href": "index.html#using-the-image",
    "title": "py-rocket-base documentation",
    "section": "Using the image",
    "text": "Using the image\nInclude a Dockerfile in your repository with the following from line:\nFROM ghcr.io/nmfs-opensci/py-rocket-base:latest\nTo extend the base image, see the documentation on using the base image. py-rocket-base includes directories called \\pyrocket_scripts and \\rocker_scripts that will help you do common tasks for extending scientific docker images. You do not have to use these scripts, but they can help you do standard installation tasks (and some tasks like properly setting up GDAL) require some experience. If you are familiar with writing Docker files, you can write your own code in your Docker file.\nThere is one exception and that is the installation of Desktop files. Properly adding Desktop applications to py-rocket-base requires the use of the \\pyrocket_scripts/install-desktop.sh script. Setting up the start file (a script that runs after the user server is started) is also unique. See the documentation.\nThis work is part of a large effort: the NMFS Open Science docker stack.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "py-rocket-base documentation",
    "section": "",
    "text": "See the Developer section of the documentation for other approaches for installing R/RStudio and the design goals for py-rocket-base.↩︎",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "customizing.html",
    "href": "customizing.html",
    "title": "1  Using py-rocket-base",
    "section": "",
    "text": "1.1 helper scripts",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Using py-rocket-base</span>"
    ]
  },
  {
    "objectID": "customizing.html#helper-scripts",
    "href": "customizing.html#helper-scripts",
    "title": "1  Using py-rocket-base",
    "section": "",
    "text": "1.1.1 pyrocket scripts\nHow to use the helper scripts is shown in configuration files. The helper scripts provide code to do common tasks. Users can write their own Docker file code to do these tasks but the helper scripts provide standardized code. The scripts are\n\ninstall-conda-packages.sh\ninstall-pip-packages.sh\ninstall-r-packages.sh\ninstall-apt-packages.sh\ninstall-vscode-extensions.sh\ninstall-desktop.sh\nsetup-start.sh\nrun-postbuild.sh\n\n\n\n1.1.2 rocker scripts\nThe rocker docker stack also includes a set of scripts for extending rocker packages. These are included py-rocket-base.\n\n\n1.1.3 Calling the scripts\nThe format for calling the pyrocket and rocker scripts is the following.\npyrocket scripts take files (or a path to a directory with Desktop files) as arguments. The COPY command is needed to copy the file into the Docker build context where it can be used in RUN commands. Without this you will get a “file not found” error. Removing the file after you are done with it will clean up your image files.\nCOPY environment.yml environment.yml\nRUN /pyrocket_scripts/install-conda-packages.sh environment.yml && \\\n  rm environment.yml\nRocker scripts do not take arguments. Note that PATH must be given since rocker installation scripts will fail with conda on the path. The path specification is only within the specific RUN context.\nUSER root\nRUN PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin && \\\n    /rocker_scripts/install_geospatial.sh\nUSER ${NB_USER}",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Using py-rocket-base</span>"
    ]
  },
  {
    "objectID": "customizing.html#repository-file-structure",
    "href": "customizing.html#repository-file-structure",
    "title": "1  Using py-rocket-base",
    "section": "1.2 Repository file structure",
    "text": "1.2 Repository file structure\nHere is a typical repo structure. Only the Dockerfile is required. The rest are optional. The exact files names, apt.txt, environment.yml, requirements.txt, install.R, etc are optional, meaning you can name these files whatever you want. The pyrocket scripts take filename or directory arguments.\nyour-repo/\n├── Dockerfile\n├── apt.txt\n├── environment.yml\n├── install.R\n├── requirements.txt\n├── postBuild\n├── start\n├── Desktop/\n│   ├── qgis.desktop\n│   ├── qgis.xml\n│   └── qgis.png\nRead configuration_files to learn about the files. Read Desktop to learn about the Desktop folder and files for applications.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Using py-rocket-base</span>"
    ]
  },
  {
    "objectID": "customizing.html#examples",
    "href": "customizing.html#examples",
    "title": "1  Using py-rocket-base",
    "section": "1.3 Examples",
    "text": "1.3 Examples\n\n1.3.1 Add some Python packages\nYou want to add some Python packages to the conda notebook environment.\nyour-repo/\n├── Dockerfile\n├── environment.yml\nDockerfile\nFROM ghcr.io/nmfs-opensci/py-rocket-base:latest\n\nCOPY environment.yml environment.yml\nRUN /pyrocket_scripts/install-conda-packages.sh environment.yml && \\\n  rm environment.yml\nenvironment.yml\nname: required\nchannels:\n  - conda-forge\ndependencies:\n  - cmocean\n  - numpy\n\n\n1.3.2 Add R packages\nAdd an R script to install packages. Important: packages that have linux dependencies (e.g. all the spatial packages depend on GDAL) will not work if you use install.packages(). GDAL will not be installed.\nyour-repo/\n├── Dockerfile\n├── install.R\nDockerfile\nFROM ghcr.io/nmfs-opensci/py-rocket-base:latest\n\nCOPY install.R install.R\nRUN /pyrocket_scripts/install-r-packages.sh install.R && rm install.R\ninstall.R\n# to match rocker/verse:4.4 used in py-rocker-base\n# look up the date that the Rocker image was created and put that\nrepo &lt;- \"https://p3m.dev/cran/__linux__/jammy/2024-05-13\"\nlist.of.packages &lt;- c(\"ncdf4\", \"httr\", \"plyr\", \"lubridate\")\ninstall.packages(list.of.packages, repos=repo)\n\n\n1.3.3 Add some linux packages\nYou want to add some linux packages with apt-get. apt-get requires root so you will need to switch to root and switch back to ${NB_USER}.\nyour-repo/\n├── Dockerfile\n├── apt.txt\nDockerfile\nFROM ghcr.io/nmfs-opensci/py-rocket-base:latest\n\nUSER root\nCOPY apt.txt apt.txt\nRUN /pyrocket_scripts/install-apt-packages.sh apt.txt && rm apt.txt\nUSER ${NB_USER}\napt.txt\n# a package\nlibgl1-mesa-glx\n\n# Another\nvim\n\n\n1.3.4 Add R geospatial packages\nGeospatial packages require some linux packages. To get this working in your Docker image add this to your Docker file:\nDockerfile\nFROM ghcr.io/nmfs-opensci/py-rocket-base:latest\n\nUSER root\nRUN PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin && \\\n    /rocker_scripts/install_geospatial.sh\nUSER ${NB_USER}\nYou have access to all the rocker scripts and you can run these similar to the line above.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Using py-rocket-base</span>"
    ]
  },
  {
    "objectID": "configuration_files.html",
    "href": "configuration_files.html",
    "title": "2  Customization scripts",
    "section": "",
    "text": "2.1 install-conda-packages.sh\nThe install-conda-packages.sh script will install conda packages to the conda notebook environment, the user environment in the py-rocket-base image (same as for pangeo and repo2docker images).\nHere is the code for your Docker file. You can name the conda package file to something other than environment.yml. Make sure your file has name:. The name is arbitrary. It is ignored but required for the script.\nThis is a standard format. You can add version pinning.\nenvironment.yml\nInstead of a list of conda packages (typically called environment.yml), you can use a conda lock file instead.\nHere is the code for your Docker file. You can name your conda lock file something other than conda-lock.yml.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Customization scripts</span>"
    ]
  },
  {
    "objectID": "configuration_files.html#install-conda-packages.sh",
    "href": "configuration_files.html#install-conda-packages.sh",
    "title": "2  Customization scripts",
    "section": "",
    "text": "COPY environment.yml environment.yml\nRUN /pyrocket_scripts/install-conda-packages.sh environment.yml && rm environment.yml\n\n\nname: required\nchannels:\n  - conda-forge\ndependencies:\n  - cmocean\n  - numpy\n\n\nCOPY conda-lock.yml conda-lock.yml\nRUN /pyrocket_scripts/install-conda-packages.sh conda-lock.yml && rm conda-lock.yml",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Customization scripts</span>"
    ]
  },
  {
    "objectID": "configuration_files.html#install-pip-packages.sh",
    "href": "configuration_files.html#install-pip-packages.sh",
    "title": "2  Customization scripts",
    "section": "2.2 install-pip-packages.sh",
    "text": "2.2 install-pip-packages.sh\nThe install-pip-packages.sh script will install packages using pip. Here is the code for your Docker file. You can name your pip package file something other than requirements.txt.\nCOPY requirements.txt requirements.txt\nRUN /pyrocket_scripts/install-pip-packages.sh requirements.txt && rm requirements.txt\nrequirements.txt\n#a package\nharmony-py",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Customization scripts</span>"
    ]
  },
  {
    "objectID": "configuration_files.html#install-r-packages.sh",
    "href": "configuration_files.html#install-r-packages.sh",
    "title": "2  Customization scripts",
    "section": "2.3 install-r-packages.sh",
    "text": "2.3 install-r-packages.sh\nThe install-r-packages.sh script will run the supplied R script which you can use to install R packages to the system library.\nHere is the code for your Docker file. You can name the R script file to something other than install.R. Make sure your file is an R script.\nCOPY install.R install.R\nRUN /pyrocket_scripts/install-r-packages.sh install.R && rm install.R\ninstall.R example\n# to match rocker/verse:4.4 used in py-rocker-base\n# look up the date that the Rocker image was created and put that\nrepo &lt;- \"https://p3m.dev/cran/__linux__/jammy/2024-05-13\"\nlist.of.packages &lt;- c(\"ncdf4\", \"httr\", \"plyr\", \"lubridate\")\ninstall.packages(list.of.packages, repos=repo)\n\n2.3.1 Add R geospatial packages\nGeospatial packages require some linux packages. To get this working in your Docker image add this to your Docker file:\nDockerfile\nFROM ghcr.io/nmfs-opensci/py-rocket-base:latest\n\nUSER root\nRUN PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin && \\\n    /rocker_scripts/install_geospatial.sh\nUSER ${NB_USER}",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Customization scripts</span>"
    ]
  },
  {
    "objectID": "configuration_files.html#install-apt-packages.sh",
    "href": "configuration_files.html#install-apt-packages.sh",
    "title": "2  Customization scripts",
    "section": "2.4 install-apt-packages.sh",
    "text": "2.4 install-apt-packages.sh\nThe install-apt-packages.sh script will install packages with apt-get. Here is the code for your Docker file. You can name the apt file of packages names to something other than apt.txt. Comments and newlines are allowed. Installation requires root.\nUSER root\nCOPY apt.txt apt.txt\nRUN /pyrocket_scripts/install-apt-packages.sh apt.txt && rm apt.txt\nUSER ${NB_USER}\napt.txt example\n# Some useful stuff\ntk-dev\n\n# Add some more\ncmocean",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Customization scripts</span>"
    ]
  },
  {
    "objectID": "configuration_files.html#run-postbuild.sh",
    "href": "configuration_files.html#run-postbuild.sh",
    "title": "2  Customization scripts",
    "section": "2.5 run-postbuild.sh",
    "text": "2.5 run-postbuild.sh\nThe run-postbuild.sh script can be run as root or jovyan (${NB_USER}). The script has some extra code to remove leftover files after installing Python extensions.\nCOPY postBuild postBuild\nRUN /pyrocket_scripts/run-postbuild.sh postBuild && rm postBuild\npostBuild\n#!/bin/bash -l\nset -e\n\n&lt;bash commands&gt;",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Customization scripts</span>"
    ]
  },
  {
    "objectID": "configuration_files.html#setup-start.sh",
    "href": "configuration_files.html#setup-start.sh",
    "title": "2  Customization scripts",
    "section": "2.6 setup-start.sh",
    "text": "2.6 setup-start.sh\nThe start bash code is run when the image starts. py-rocker-base has a start script at ${REPO_DIR}/start which loads the Desktop applications. If you change that start file (by copying your start file onto that location), then the Desktop apps will not be loaded properly. Instead, the setup-start.sh will add your start file to a directory ${REPO_DIR}/childstarts and will run all those scripts after ${REPO_DIR}/start.\nThe setup-start.sh script will move the file you provide into ${REPO_DIR}/childstarts. As usual you can name your script something other than start.\nCOPY start start\nRUN /pyrocket_scripts/setup-start.sh start && rm start",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Customization scripts</span>"
    ]
  },
  {
    "objectID": "configuration_files.html#install-vscode-extensions.sh",
    "href": "configuration_files.html#install-vscode-extensions.sh",
    "title": "2  Customization scripts",
    "section": "2.7 install-vscode-extensions.sh",
    "text": "2.7 install-vscode-extensions.sh\nThe install-vscode-extensions.sh script will add VSCode extensions.\nCOPY vscode-extensions.txt vscode-extensions.txt\nRUN /pyrocket_scripts/install-vscode-extensions.sh vscode-extensions.txt && \\\n  rm vscode-extensions.txt\nvscode-extensions.txt\ngitlens\nindent-rainbow\ncode-spell-checker\nprettier",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Customization scripts</span>"
    ]
  },
  {
    "objectID": "configuration_files.html#desktop-applications",
    "href": "configuration_files.html#desktop-applications",
    "title": "2  Customization scripts",
    "section": "2.8 Desktop applications",
    "text": "2.8 Desktop applications\nSee the chapter on Desktop applications.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Customization scripts</span>"
    ]
  },
  {
    "objectID": "r-packages.html",
    "href": "r-packages.html",
    "title": "3  R packages",
    "section": "",
    "text": "To install extra R packages, use install.R. This is treated as an R script which is run. For example, you can have a script like\ninstall.R\nrepo &lt;- \"https://p3m.dev/cran/__linux__/jammy/2024-05-13\"\nlist.of.packages &lt;- c(\"ggplot2\",\"remotes\")\ninstall.packages(list.of.packages, repos=repo)\nremotes::install_github(\"hadley/httr@v0.4\")\n\n3.0.1 Spatial libraries\nSome packages depend on linux packages. One example are spatial packages like sf which depend on GDAL. In this case\ninstall.packages(\"sf\")\nwill not work because it will not install the linux package dependencies.\nThere are a few ways to get around this.\n\nInstall the necessary linux packages via apt-get. This can be hard.\nInstall via via /rocker_scipts/install_geospatial.sh To do this include\nRUN /rocker_scipts/install_geospatial.sh\nin your Dockerfile.\nUse r2u which has Ubuntu binaries with all the dependencies included.\n\n\n\n3.0.2 Default CRAN repository\nThe default CRAN repository is set in ${R_HOME}/etc/Rprofile.site and the CRAN environmental variable to\nhttps://p3m.dev/cran/__linux__/jammy/latest\nTo set a different repo, edit ${R_HOME}/etc/Rprofile.site or specify the repo to use in install.packages() like so\nrepo &lt;- \"https://p3m.dev/cran/__linux__/jammy/2024-05-13\"\nlist.of.packages &lt;- c(\"maps\", \"mapdata\", \"RColorBrewer\")\ninstall.packages(list.of.packages, repos=repo)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R packages</span>"
    ]
  },
  {
    "objectID": "desktop.html",
    "href": "desktop.html",
    "title": "4  Desktop",
    "section": "",
    "text": "4.1 Adding an application in your child docker image\nUse the pyrocket script install-desktop.sh to set up the desktop and move your files to the proper location. Provide a path to a directory with your Desktop files as the argument to the script. Here is the code for your Docker file. This script must be run as root.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Desktop</span>"
    ]
  },
  {
    "objectID": "desktop.html#adding-an-application-in-your-child-docker-image",
    "href": "desktop.html#adding-an-application-in-your-child-docker-image",
    "title": "4  Desktop",
    "section": "",
    "text": "USER root\nCOPY ./Desktop /tmp/Desktop\nRUN /pyrocket_scripts/install-desktop.sh  /tmp/Desktop\nRUN rm -rf /tmp/Desktop\nUSER ${NB_USER}\n\n4.1.1 Create the Desktop directory\nCreate a directory for the Desktop file and add the .desktop and optional .png and .xml files. The pyrocket script install_desktop.sh will move them to the correct places (/usr/share/applications and /usr/share/Desktop, /usr/share/mime/packages and icon locations).\nyour-repo/\n├── Dockerfile\n├── optional extra files\n├── Desktop/\n│   ├── qgis.desktop\n│   ├── qgis.xml\n│   └── qgis.png\n\n4.1.1.1 .desktop file\nThe .desktop file is a configuration file that describes how an application is launched. The required parts are Name, Exec and Type. MimeType specifies what types of files the application can use (optional). If you included an icon in your Desktop directory, then that will be registered and you can use the filename without a path. However, sometimes the icon is installed with the application and in that case you need the full path. See the icon section below.\ncdat.desktop\n[Desktop Entry]\nType=Application\nName=CWUtils\nGenericName=CoastWatch Data Analysis Tool\nIcon=cdat\nTryExec=cdat\nExec=cdat %F\nTerminal=false\nStartupNotify=false\nCategories=Qt;Education;Science;Geography;\nKeywords=map;globe;\n\n\n4.1.1.2 .xml\nYou can specify the mime types via xml.\n\n\n4.1.1.3 icons\nYou can include a png or svg for the icon. py-rocket-base will place this in /usr/share/icons/hicolor. If you put your icon file in the Desktop directory in your repo, then in your desktop file, use the file name without the extension. If for some reason, your icon is not showing up, use the direct url /srv/repo/Desktop/your-icon-name.png. If the icon cache does not update properly, you have the use the full url.\nIcon=cdat\nYou can also use an absolute file path.\nIf an icon is installed with your application, it will be in the installation files.\nIcon=/srv/conda/envs/notebook/share/qgis/images/icons/qgis-icon-512x512.png\nor if you include an icon in your Desktop directory, it will be in /srv/repo/Desktop (but in that case it is also registered as an icon so you can just use cdat).\nIcon=/srv/repo/Desktop/cdat.png\n\n\n\n4.1.2 Install the application\nHow you install the application really varies. Here are 2 examples.\nQGIS\n\nadd qgis to environment.yml\nadd libgl1-mesa-glx to apt.txt\nadd the qgis.desktop file to your Desktop directory\n\nqgis.desktop\n# From: https://github.com/qgis/QGIS/blob/ltr-3_28/linux/org.qgis.qgis.desktop.in\n[Desktop Entry]\nType=Application\nName=QGIS Desktop\nGenericName=Geographic Information System\nIcon=/srv/conda/envs/notebook/share/qgis/images/icons/qgis-icon-512x512.png\nTryExec=qgis\nExec=qgis %F\nTerminal=false\nStartupNotify=false\nCategories=Qt;Education;Science;Geography;\nMimeType=application/x-qgis-project;application/x-qgis-project-container;application/x-qgis-layer-settings;application/x-qgis-layer-definition;application/x-qgis-composer-template;image/tiff;image/jpeg;image/jp2;application/x-raster-aig;application/x-raster-ecw;application/x-raster-mrsid;application/x-mapinfo-mif;application/x-esri-shape;application/vnd.google-earth.kml+xml;application/vnd.google-earth.kmz;application/geopackage+sqlite3;\nKeywords=map;globe;postgis;wms;wfs;ogc;osgeo;\nStartupWMClass=QGIS3\nCoastWatch Utilities\nAdd this to the docker file to install\nUSER root\n# Install cwutils\nRUN cd /tmp && \\\n    wget https://www.star.nesdis.noaa.gov/socd/coastwatch/cwf/cwutils-4_0_0_198-linux-x86_64.tar.gz && \\\n    tar -zxf cwutils-4_0_0_198-linux-x86_64.tar.gz && \\\n    rm -rf cwutils-4_0_0_198-linux-x86_64.tar.gz\nENV PATH=${PATH}:/tmp/cwutils_4.0.0.198/bin\nENV MANPATH=${MANPATH}:/tmp/cwutils_4.0.0.198/doc/man\nENV INSTALL4J ADD VM PARAMS=-Dsun.java2d.uiScale=2.0\nUSER ${NB_USER}\nAdd this cdat.desktop file to Desktop directory\n[Desktop Entry]\nType=Application\nName=CWUtils\nGenericName=CoastWatch Data Analysis Tool\nIcon=/srv/repo/Desktop/cdat.png\nTryExec=cdat\nExec=cdat %F\nTerminal=false\nStartupNotify=false\nCategories=Qt;Education;Science;Geography;\nKeywords=map;globe;\nAdd cdat.png icon to Desktop directory. How do you know that the command to open the application is cdat? You read the application installation documentation and it will tell you how to open the application from a terminal (command line).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Desktop</span>"
    ]
  },
  {
    "objectID": "desktop.html#whats-happening",
    "href": "desktop.html#whats-happening",
    "title": "4  Desktop",
    "section": "4.2 What’s happening",
    "text": "4.2 What’s happening\nTo add new desktop applications, one needs to do the following. py-rocket-base does these steps automatically (via the start script) so that the user only has to put files into a Desktop directory in the docker build repo.\n\nInstall the application. See examples.\nAdd a .desktop file to an application directory. py-rocket-base puts these in /usr/share/applications but you will also see ${HOME}/.local/share/applications/.\nTo have an icon on the Desktop, you create a folder Desktop and tell XDG what directory to use. The directory is specified in ~/.config/user-dirs.dirs which XDG sets. By default (XDG), this folder is ~/Desktop but you can set it to something else. py-rocket-base sets a default value in /etc/xdg/user-dirs.defaults. This updates ~/.config/user-dirs.dirs when the /etc/xdg/xfce4/xinitrc start script is run (when the /desktop button is clicked).\nXDG looks for .desktop files in the Desktop directory. py-rocket-base creates a soft link to the .desktop files in /usr/share/applications/ in /usr/share/Desktop.\n\nSee this Medium article for a description.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Desktop</span>"
    ]
  },
  {
    "objectID": "publishing.html",
    "href": "publishing.html",
    "title": "5  Publishing",
    "section": "",
    "text": "5.1 Quarto\nQuarto is a full-feature platform for creation of documents, books and webpages in a variety of formats. Explore the documentation at https://quarto.org/. You can use Quarto in JupyterLab, RStudio or VSCode. RStudio has the most featured integration followed by VSCode. JupyterLab integration is somewhat minimal.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Publishing</span>"
    ]
  },
  {
    "objectID": "publishing.html#quarto",
    "href": "publishing.html#quarto",
    "title": "5  Publishing",
    "section": "",
    "text": "5.1.1 RStudio\nQuarto is fully integrated with RStudio. Use the Render and Build buttons.\nSpecial note regarding creating pdfs\nRendering to PDF or format: pdf should work fine and packages will be installed on the fly. But the package installations will not persist and you will need to install them again after you restart the server.\n\n\n5.1.2 VSCode\nThe VSCode Quarto extension is installed. This provides many nice features. Read about them on the Quarto VSCode page. The extension includes keyboard shortcuts for rendering or you can render from a terminal.\n\n\n5.1.3 Jupyter Lab\nThe jupyterlab-quarto package is installed which allows Quarto markdown to be rendered in markdown cells in Jupyter notebooks (ipynb). But you will need to render from a terminal. Quarto render both qmd and ipynb files. Read about using Quarto with JupyterLab on this Quarto page. For example,\nquarto render --to pdf test.qmd\nquarto render --to html test.ipynb\nFor PDF output, TexLive packages will not install on the fly and you will need to do tlmgr install packagename for any missing package errors you get.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Publishing</span>"
    ]
  },
  {
    "objectID": "publishing.html#myst",
    "href": "publishing.html#myst",
    "title": "5  Publishing",
    "section": "5.2 MyST",
    "text": "5.2 MyST\n\n\n\n\nMyST is an Python ecosystem of tools for creating interactive scientific publications for the web or export to PDF, LaTeX and Microsoft Word. jupyterlab-myst extension is installed. Read more about MyST in JupyterLab here. The MyST VSCode extension is also installed if you are editting MyST markdown in VSCode.\n\nCreating PDFs with Myst\nYou can output to PDF like so from a terminal: jupyter nbconvert --to pdf test.ipynb. However. TexLive packages will not install on the fly and you will need to do tlmgr install packagename for any missing package errors you get.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Publishing</span>"
    ]
  },
  {
    "objectID": "publishing.html#sphinx",
    "href": "publishing.html#sphinx",
    "title": "5  Publishing",
    "section": "5.3 Sphinx",
    "text": "5.3 Sphinx\n\n\n\n\nSphinx is a commonly used package for creating documentation for Python packages.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Publishing</span>"
    ]
  },
  {
    "objectID": "publishing.html#texlive",
    "href": "publishing.html#texlive",
    "title": "5  Publishing",
    "section": "5.4 TexLive",
    "text": "5.4 TexLive\n\n\n\n\npy-rocket-base has Quarto and Myst installed along with pandoc and TeXLive for output to PDF. The tlmgr is used (and must be used) to manage packages.\n\n\n5.4.1 Installing new TexLive packages\ntlmgr must be used.\n\nDo not use apt-get to install texlive packages. This will turn off tlmgr (the TeX package manager). Instead use\n\ntlmgr install &lt;package&gt;\n\nRun tlmgr option to make sure tlmgr is working.\n\nUnfortunately any packages you install will be in the /opt directory and this gets recreated every time you restart your server. So if you need a particular package you will need to keep installing it. Or create your own image based on py-rocket-base:\nDockerfile\nFROM ghcr.io/nmfs-opensci/py-rocket-base:latest\n\nRUN tlmgr install collection-latexrecommended && tlmgr clean --all",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Publishing</span>"
    ]
  },
  {
    "objectID": "jupyter-config.html",
    "href": "jupyter-config.html",
    "title": "6  Customizing Jupyter",
    "section": "",
    "text": "If you want to customize some feature of the JupyterHub or JupyterLab, you can do this by passing in *.json or *.py configuration files. In py-rocket-base, these are in the jupyter_server_config.d and jupyter_notebook_config.d directories in the conda notebook environment. These directories contain the json that specifies the configurations:\n/srv/conda/envs/notebook/\n└── etc/\n    └── jupyter/\n        └── jupyter_server_config.d/\n            ├── security.json\n            ├── extensions.json\n            └── custom.json\n        └── jupyter_notebook_config.d/\n            └── custom.json\nIf you want to change these configurations, you need to either update the file with the configuration or add a new configuration file. You can add either .json or .py configurations files to the same directory.\nFor example, if you want to allow hidden files to be shown in the file browser in Jupyter Lab. Add\ncustom_jupyter_server_config.json\n{\n    \"ContentsManager\": {\n        \"allow_hidden\": true\n    }\n}\nand then copy this into jupyter_server_config.d and jupyter_notebook_config.d via code in the Dockerfile or in postBuild. We copy both to notebook server config and jupyter server config, because either can be used in the JupyterHub.\nDockerfile\nCOPY custom_jupyter_server_config.json custom_jupyter_server_config.json\nRUN cp custom_jupyter_server_config.json ${NB_PYTHON_PREFIX}/etc/jupyter/jupyter_server_config.d/ && \\\n    cp custom_jupyter_server_config.json ${NB_PYTHON_PREFIX}/etc/jupyter/jupyter_notebook_config.d/ && \\\n    rm custom_jupyter_server_config.json\nAlternatively, you can add a postBuild file to your repo and py-rocket-base will automatically run this when you image builds.\npostBuild\n#!/bin/bash -l\nset -euo pipefail\n\ncp custom_jupyter_server_config.json ${NB_PYTHON_PREFIX}/etc/jupyter/jupyter_server_config.d/\ncp custom_jupyter_server_config.json ${NB_PYTHON_PREFIX}/etc/jupyter/jupyter_notebook_config.d/",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Customizing Jupyter</span>"
    ]
  },
  {
    "objectID": "developers.html",
    "href": "developers.html",
    "title": "7  Developer notes",
    "section": "",
    "text": "7.1 Design\npy-rocket-base is inspired by repo2docker and the Pangeo Docker stack design. py-rocker-base is built using repo2docker (via repo2docker-action) and thus lets repo2docker make the choices regarding the environment design—things like how the conda environment is set-up and the base directory structure and permissions.\nThe Pangeo Docker stack does not use repo2docker, but mimics repo2docker’s environment design. The Pangeo base-image behaves similar to repo2docker in that using the base-image in the FROM line of a Dockerfile causes the build to look for files with the same names as repo2docker’s configuration files and then do the proper action with those files. This means that routine users do not need to know how to write Dockerfile code in order to extend the image with new packages or applications. py-rocker-base Docker image uses this Pangeo base-image design. It is based on ONBUILD commands in the Dockerfile that trigger actions only when the image is used in the FROM line of another Dockerfile.\npy-rocket-base does not include this ONBUILD behavior. Instead it follows the rocker docker stack design and provides helper scripts for building on the base image. py-rocket-base a directory called \\pyrocket_scriptsthat will help you do common tasks for scientific docker images.These scripts are not required. If users are familiar with writing Docker files, they can write their own code. The use of helper scripts was used after feedback that the Pangeo ONBUILD behavior makes it harder to customize images that need very specific structure or order of operations.\nThere are many ways to install R and RStudio into an image designed for JupyterHubs The objective of py-rocker-base is not to install R and RStudio, per se, and there are other leaner and faster ways to install R/RStudio if that is your goal1. The objective of py-rocket-base is to create an JupyterHub image such when you click the RStudio button in the JupyterLab UI to enter the RStudio UI, you enter an environment that is the same as if you had used a Rocker image. If you are in the JupyterLab UI, the environment is the same as it you had used repo2docker (or Pangeo base-image) to create the environment.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Developer notes</span>"
    ]
  },
  {
    "objectID": "developers.html#design",
    "href": "developers.html#design",
    "title": "7  Developer notes",
    "section": "",
    "text": "See for example repo2docker-r and conda-r in binder-examples.↩︎",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Developer notes</span>"
    ]
  },
  {
    "objectID": "developers.html#documentation",
    "href": "developers.html#documentation",
    "title": "7  Developer notes",
    "section": "7.2 Documentation",
    "text": "7.2 Documentation\nTo build the documentation book, clone repo and then\ncd book\nquarto render .\nSet GitHub Pages to docs folder.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Developer notes</span>"
    ]
  },
  {
    "objectID": "developers.html#building-the-images",
    "href": "developers.html#building-the-images",
    "title": "7  Developer notes",
    "section": "7.3 Building the images",
    "text": "7.3 Building the images\nThe .github/workflows/build.yaml is a GitHub Action to build the image with repo2docker-action. The GitHub Action builds the image and the URL will look like one of these\nghcr.io/nmfs-opensci/repo-name/image-name:latest\nghcr.io/nmfs-opensci/image-name:latest\nFor example, for this repo the image is ghcr.io/nmfs-opensci/py-rocket-base:latest.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Developer notes</span>"
    ]
  },
  {
    "objectID": "developers.html#repo2docker",
    "href": "developers.html#repo2docker",
    "title": "7  Developer notes",
    "section": "7.4 repo2docker",
    "text": "7.4 repo2docker\nrepo2docker-action is creating the image and publishing to ghcr.io/nmfs-opensci/py-rocket-base (image hosting like dockerhub or quay.io).\nrepo2docker (a python package) sets up the structure of the base environment, e.g. installs mamba for package solving, sets up environment variables, installs linux packages, etc. It looks for specific files (like apt.txt, environment.yml, postBuild) in the build context (the repo that the Dockerfile is in) and takes the appropriate action. repo2docker-action also allows you to include appendix to add more commands to your Dockerfile.\nrepo2docker does a lot behind the scene and has some different behavior.\n\n7.4.1 COPY\nCOPY &lt;src&gt; &lt;dest&gt; does not work in appendix because repo2docker changes the build context. The files are in src not .. In appendix, you do not do lines like this\nCOPY file1 newlocation/file1\nto bring file1 into the build. Instead, the files are already in ${REPO_DIR}/. If you want to copy a file to a new location, run the following as root if jovyan does not have permission to write to newlocation.\nRUN cp ${REPO_DIR}/file1 newlocation/file1\n\n\n7.4.2 ENV and ARGS\nrepo2docker uses a number of ARGs in the build which you might expect to be in the image environment, for example ${NB_USER}. These need to be converted to ENV to be available to child builds.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Developer notes</span>"
    ]
  },
  {
    "objectID": "developers.html#rstudio",
    "href": "developers.html#rstudio",
    "title": "7  Developer notes",
    "section": "7.5 RStudio",
    "text": "7.5 RStudio\njupyter-rsession-proxy allows us to launch RStudio from Jupyter Lab, but the environment is different than the environment in Jupyter Lab.\n\n7.5.1 Environmental variables\n\nPATH is different. conda is not on the path.\nNone of the environmental variables in the docker file will be in the /rstudio environment. The start command affects \\lab and \\notebook but not \\rstudio.\nThe path in the terminal (in RStudio) can/is different than in the R console. Expect weird unexpected behavior because of this. If you type bash, then .bashrc is run and that will run conda init and that will add conda binaries to the path. Then really weird and unexpected things can happen.\n\nIf you need some environmental variable set, you will need to set those in $R_HOME/etc/Rprofile.site which is run when R starts.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Developer notes</span>"
    ]
  },
  {
    "objectID": "developers.html#basic-structure-of-py-rocket-base",
    "href": "developers.html#basic-structure-of-py-rocket-base",
    "title": "7  Developer notes",
    "section": "7.6 Basic structure of py-rocket-base",
    "text": "7.6 Basic structure of py-rocket-base\nThe py-rocket-base docker build has the following structure:\n# base image and environment\nrepo2docker sets this up\nrepo2docker-action sets the directory where the build files \n  are put to /srv/repo (via $REPO_DIR in GitHub Action)\n  and ownership is set to jovyan (via $NB_USER)\n  \n# environment.yml\nrepo2docker adds these packages to the conda notebook environment\n\n# start\nrepo2docker points the Docker image entrypoint (command run on start) to this file\n${REPO_DIR}/start\n\n# appendix\nrepo2docker-action adds the Docker commands here to the end of Dockerfile\nmost of the work in py-rocket-base is done here. appendix calls rocker.sh and install packages in apt2.txt\nEach file is described below.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Developer notes</span>"
    ]
  },
  {
    "objectID": "developers.html#apt2.txt",
    "href": "developers.html#apt2.txt",
    "title": "7  Developer notes",
    "section": "7.7 apt2.txt",
    "text": "7.7 apt2.txt\nThis is not named apt.txt because these packages need to be installed after R is installed because the R scripts uninstall packages as part of cleanup. There are some packages that are required for Desktop (/desktop) to operate correctly. Packages needed for R and RStudio building (/rstudio) are installed via the rocker install scripts.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Developer notes</span>"
    ]
  },
  {
    "objectID": "developers.html#environment.yml",
    "href": "developers.html#environment.yml",
    "title": "7  Developer notes",
    "section": "7.8 environment.yml",
    "text": "7.8 environment.yml\nThese are added to the notebook conda environment and in py-rocket-base the basic packages needed for Jupyter Lab, RStudio and Desktop are added. Scientific packages are not added here. They will be added via child images that use py-rocket-base as the base image (in the FROM line).",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Developer notes</span>"
    ]
  },
  {
    "objectID": "developers.html#appendix",
    "href": "developers.html#appendix",
    "title": "7  Developer notes",
    "section": "7.9 appendix",
    "text": "7.9 appendix\nThis a long file with many pieces. The pieces are explained below. Click on the number next to code to read about what that code block does.\n1USER root\n\n2# Set env variables\n# This is the default env in repo2docker type images\nENV CONDA_ENV=notebook\n# Tell applications where to open desktop apps\nDISPLAY=\":1.0\"\n\n# Install R, RStudio via Rocker scripts\n3ENV R_VERSION=\"4.4.1\"\nENV R_DOCKERFILE=\"verse_${R_VERSION}\"\n# This is in the rocker script but will not run since ${NB_USER} already exists\n# Needed because rocker scripts set permissions based on the staff group\nRUN usermod -a -G staff \"${NB_USER}\"\nRUN PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin && \\\n  chmod +x ${REPO_DIR}/rocker.sh && \\\n  ${REPO_DIR}/rocker.sh\n\n4# Install linux packages after R installation since the R install scripts get rid of packages\n# The package_list part is reading the file and doing clean-up to just have the list of packages\nRUN package_list=$(grep -v '^\\s*#' ${REPO_DIR}/apt2.txt | grep -v '^\\s*$' | sed 's/\\r//g; s/#.*//; s/^[[:space:]]*//; s/[[:space:]]*$//' | awk '{$1=$1};1') && \\\n  apt-get update && \\\n  apt-get install --yes --no-install-recommends $package_list && \\\n  apt-get autoremove --purge && \\\n  apt-get clean && \\\n  rm -rf /var/lib/apt/lists/*\n  \n# Re-enable man pages disabled in Ubuntu 18 minimal image\n# https://wiki.ubuntu.com/Minimal\n5RUN yes | unminimize\n# NOTE: $NB_PYTHON_PREFIX is the same as $CONDA_PREFIX at run-time.\n# $CONDA_PREFIX isn't available in this context.\n# NOTE: Prepending ensures a working path; if $MANPATH was previously empty,\n# the trailing colon ensures that system paths are searched.\nENV MANPATH=\"${NB_PYTHON_PREFIX}/share/man:${MANPATH}\"\nRUN mandb\n\n# Add custom jupyter config. You can also put config.py files in the same place\n6COPY custom_jupyter_server_config.json ${NB_PYTHON_PREFIX}/etc/jupyter/jupyter_server_config.d/\nCOPY custom_jupyter_server_config.json ${NB_PYTHON_PREFIX}/etc/jupyter/jupyter_notebook_config.d/\n\n# Clean up extra files in ${REPO_DIR}\n7RUN rm -rf ${REPO_DIR}/book ${REPO_DIR}/docs\n\n# Copy scripts into /pyrocket_scripts directory in the image\n8RUN mkdir -p /pyrocket_scripts && cp -r ${REPO_DIR}/scripts/* /pyrocket_scripts/\n\n# Set ownership to root and permissions to 755\nRUN chown -R root:staff /pyrocket_scripts && \\\n    chmod -R 775 /pyrocket_scripts\n\n# Convert NB_USER to ENV (from ARG) so that it passes to the child dockerfile\n9ENV NB_USER=${NB_USER}\n\n# Revert to default user and home as pwd\n10USER ${NB_USER}\nWORKDIR ${HOME}\n\n1\n\nSome commands need to be run as root, such as installing linux packages with apt-get\n\n2\n\nSet variables. CONDA_ENV is useful for child builds\n\n3\n\nThis section runs the script rocker.sh which installs R and RStudio using rocker scripts.\n\n4\n\nThe rocker scripts build R from source and as part of clean up in the script, linux packages are removed that are not needed. repo2docker installs the packages in apt.txt automatically before the code in appendix thus the needed linux packages (which include packages for the Xfce Desktop Environment in \\desktop) are put in apt2.txt. repo2docker will not detect this file and we can install the packages here after R is built. The grep -v etc code is processing apt2.txt and removing comments and blank lines.\n\n5\n\nUbuntu does not have man pages installed by default. These lines activate man so users have the common help files.\n\n6\n\nThis is some custom jupyter config to allow hidden files to be listed in the folder browser.\n\n7\n\nbook and docs are the documentation files and are not needed in the image.\n\n8\n\nCopy the pyrocket helper scripts to the /pyrocket_scripts directory and set to executable.\n\n9\n\nThe NB_USER environmental variable is not exported by repo2docker (it is an argument confined to the parent build) but is very useful for child builds. So it is converted to an environmental variable.\n\n10\n\nThe parent docker build completes by setting the user to jovyan and the working directory to ${HOME}. Within a JupyterHub deployment, ${HOME} will often be re-mapped to the user persistent memory so it is important not to write anything that needs to be persistent to ${HOME}, for example configuration. You can do this in the start script since that runs after the user directory is mapped or you can put configuration files in some place other than ${HOME}.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Developer notes</span>"
    ]
  },
  {
    "objectID": "developers.html#rocker.sh",
    "href": "developers.html#rocker.sh",
    "title": "7  Developer notes",
    "section": "7.10 rocker.sh",
    "text": "7.10 rocker.sh\nThis script will copy in the rocker scripts from rocker-versioned2 into ${REPO_DIR} to install things. It will read in one of the rocker docker files using R_DOCKERFILE defined in the appendix file (which is inserted into the main docker file). Variables defined here will only be available in this script. Click on the numbers in the script to learn what each section is doing.\n#!/bin/bash\nset -e\n\n# Copy in the rocker files. Work in ${REPO_DIR} to make sure I don't clobber anything\n1cd ${REPO_DIR}\nwget https://github.com/rocker-org/rocker-versioned2/archive/refs/tags/R${R_VERSION}.tar.gz\ntar zxvf R${R_VERSION}.tar.gz && \\\n2mv rocker-versioned2-R${R_VERSION}/scripts /rocker_scripts && \\\n3ROCKER_DOCKERFILE_NAME=\"${R_DOCKERFILE}.Dockerfile\"\nmv rocker-versioned2-R${R_VERSION}/dockerfiles/${ROCKER_DOCKERFILE_NAME}  /rocker_scripts/original.Dockerfile && \\\n4rm R${R_VERSION}.tar.gz && \\\nrm -rf rocker-versioned2-R${R_VERSION}\n\n5cd /\n6# Read the Dockerfile and process each line\nwhile IFS= read -r line; do\n7    # Check if the line starts with ENV or RUN\n    if [[ \"$line\" == ENV* ]]; then\n        # Assign variable\n        var_assignment=$(echo \"$line\" | sed 's/^ENV //g')\n8        # Replace ENV DEFAULT_USER=\"jovyan\"\n        if [[ \"$var_assignment\" == DEFAULT_USER* ]]; then\n            var_assignment=\"DEFAULT_USER=${NB_USER}\"\n        fi\n        # Run this way eval \"export ...\" otherwise the \" will get turned to %22\n9        eval \"export $var_assignment\"\n        # Write the exported variable to env.txt\n10        echo \"export $var_assignment\" &gt;&gt; ${REPO_DIR}/env.txt\n11    elif [[ \"$line\" == RUN* ]]; then\n        # Run the command from the RUN line\n        cmd=$(echo \"$line\" | sed 's/^RUN //g')\n        echo \"Executing: $cmd\"\n        eval \"$cmd\" # || echo ${cmd}\" encountered an error, but continuing...\"\n    fi\n12done &lt; /rocker_scripts/original.Dockerfile\n\n13# Install extra tex packages that are not installed by default\nif command -v tlmgr &&gt; /dev/null; then\n    echo \"Installing texlive collection-latexrecommended...\"\n    tlmgr install collection-latexrecommended\n    tlmgr install pdfcol tcolorbox eurosym upquote adjustbox titling enumitem ulem soul rsfs\nfi\n\n1\n\nThe rocker-versioned2 repository for a particular R version is copied into {REPO_DIR} and unzipped. R_VERSION is defined in appendix.\n\n2\n\nThe unzipped directory will be named rocker-versioned2-R${R_VERSION}. We move the scripts directory to /rocker_scripts (base level) because the rocker scripts expect the scripts to be there.\n\n3\n\nR_DOCKERFILE is defined as verse_${R_VERSION}. The docker file we will process (find ENV and RUN lines) is called ROCKER_DOCKERFILE_NAME in the rocker files. We move this to /rocker_scripts/original.Dockerfile so we can refer to it later.\n\n4\n\nClean up the rocker directories that we no longer need.\n\n5\n\ncd to the base level where /rocker_scripts is.\n\n6\n\nThe big while loop is processing /rocker_scripts/original.Dockerfile. The code is using piping &gt; and the input file and pipe is specified at the end of the while loop code.\n\n7\n\nThis looks if the line starts with ENV and if it does, it strips off ENV and stores the variable assigment statement to $var_assignment.\n\n8\n\nThe rocker docker files do not use the NB_USER environmental variable (defined in appendix). If the ENV line is defining the default user, we need to change that assignment to the variable NB_USER. This part is specific to the rocker docker files.\n\n9\n\nWe need to export any variables (ENV) found in the docker file so it is available to the scripts that will run in the RUN statements. We need to export the variables as done here (with eval and export) otherwise they don’t make it to the child scripts about to be run. Getting variables to be exported to child scripts being called by a parent script is tricky and this line required a lot of testing and debugging to get variables exported properly.\n\n10\n\nThe export line will only make the variable available to the child scripts. We also want them available in the final image. To do that, we write them to a file that we will source from the docker file. Scripts are run in an ephemeral subshell during docker builds so we cannot define the variable here.\n\n11\n\nIf the docker file line starts with RUN then run the command. This command should be a rocker script because that is how rocker docker files are organized. See an example rocker docker file.\n\n12\n\nHere the input file for the while loop is specified.\n\n13\n\nThe rocker install_texlive.sh script (which is part of verse) will provide a basic texlive installation. Here a few more packages are added so that the user is able to run vanilla Quarto to PDF and Myst to PDF. See the chapter on texlive.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Developer notes</span>"
    ]
  },
  {
    "objectID": "developers.html#start",
    "href": "developers.html#start",
    "title": "7  Developer notes",
    "section": "7.11 start",
    "text": "7.11 start\nWithin a JupyterHub, the user home directory $HOME is typically re-mapped to the user persistent home directory. That means that the image build process cannot put things into $HOME, they would just be lost when $HOME is re-mapped. If a process needs to have something in the home directory, e.g. in some local user configuration, this must be done in the start script. The repo2docker docker image specifies that the start script is ${REPO_DIR}/start. In py-rocket-base, the start scripts in a child docker file is souces in a subshell from the py-rocket-base start script.\n#!/bin/bash\nset -euo pipefail\n\n1# Start - Set any environment variables here\n# These are inherited by all processes, *except* RStudio\n# USE export &lt;parname&gt;=value\n# source this file to get the variables defined in the rocker Dockerfile\nsource ${REPO_DIR}/env.txt\n# End - Set any environment variables here\n\n# Run child start scripts in a subshell to contain its environment\n# ${REPO_DIR}/childstart/ is created by setup-start.sh\n2if [ -d \"${REPO_DIR}/childstart/\" ]; then\n    for script in ${REPO_DIR}/childstart/*; do\n        if [ -f \"$script\" ]; then\n            echo \"Sourcing script: $script\"\n            source \"$script\" || {\n                echo \"Error: Failed to source $script. Moving on to the next script.\"\n            }\n        fi\n    done\nfi\nexec \"$@\"\n\n1\n\nIn a Docker file so no way to dynamically set environmental variables, so the env.txt file with the export &lt;var&gt;=&lt;value&gt; are source at start up.\n\n2\n\nRun any child start script in a subshell. Run in a subshell to contain any set statements or similar. start scripts are moved into childstarts by the setup-start.sh pyrocket script.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Developer notes</span>"
    ]
  },
  {
    "objectID": "developers.html#desktop.sh",
    "href": "developers.html#desktop.sh",
    "title": "7  Developer notes",
    "section": "7.12 desktop.sh",
    "text": "7.12 desktop.sh\nThe default for XDG and xfce4 is for Desktop files to be in ~/Desktop but this leads to a variety of problems. First we are altering the user directiory which seems rude, second orphan desktop files might be in ~/Desktop so who knows what the user Desktop experience with be, here the Desktop dir is set to /usr/share/Desktop so is part of the image. Users that really want to customize Desktop can change ~/.config/user-dirs.dirs. Though py-rocket-base might not respect that. Not sure why you’d do that instead of just using a different image that doesn’t have the py-rocket-base behavior.\n#!/bin/bash\nset -e\n\n# Copy in the Desktop files\n1APPLICATIONS_DIR=/usr/share/applications\n2DESKTOP_DIR=/usr/share/Desktop\nmkdir -p \"${DESKTOP_DIR}\"\nchown :staff /usr/share/Desktop\nchmod 775 /usr/share/Desktop\n# set the Desktop dir default for XDG\n3echo 'XDG_DESKTOP_DIR=\"${DESKTOP_DIR}\"' &gt; /etc/xdg/user-dirs.defaults\n\n# The for loops will fail if they return null (no files). Set shell option nullglob\nshopt -s nullglob\n\n4for desktop_file_path in ${REPO_DIR}/Desktop/*.desktop; do\n    cp \"${desktop_file_path}\" \"${APPLICATIONS_DIR}/.\"\n    # Symlink application to desktop and set execute permission so xfce (desktop) doesn't complain\n    desktop_file_name=\"$(basename ${desktop_file_path})\"\n    # Set execute permissions on the copied .desktop file\n    chmod +x \"${APPLICATIONS_DIR}/${desktop_file_name}\"\n    ln -sf \"${APPLICATIONS_DIR}/${desktop_file_name}\" \"${DESKTOP_DIR}/${desktop_file_name}\"\ndone\nupdate-desktop-database \"${APPLICATIONS_DIR}\"\n\n5# Add MIME Type data from XML files  to the MIME database.\nMIME_DIR=\"/usr/share/mime\"\nMIME_PACKAGES_DIR=\"${MIME_DIR}/packages\"\nmkdir -p \"${MIME_PACKAGES_DIR}\"\nfor mime_file_path in ${REPO_DIR}/Desktop/*.xml; do\n    cp \"${mime_file_path}\" \"${MIME_PACKAGES_DIR}/.\"\ndone\nupdate-mime-database \"${MIME_DIR}\"\n\n6# Add icons\nICON_DIR=\"/usr/share/icons\"\nICON_PACKAGES_DIR=\"${ICON_DIR}/packages\"\nmkdir -p \"${ICON_PACKAGES_DIR}\"\nfor icon_file_path in \"${REPO_DIR}\"/Desktop/*.png; do\n    cp \"${icon_file_path}\" \"${ICON_PACKAGES_DIR}/\" || echo \"Failed to copy ${icon_file_path}\"\ndone\nfor icon_file_path in \"${REPO_DIR}\"/Desktop/*.svg; do\n    cp \"${icon_file_path}\" \"${ICON_PACKAGES_DIR}/\" || echo \"Failed to copy ${icon_file_path}\"\ndone\ngtk-update-icon-cache \"${ICON_DIR}\"\n\n1\n\nThis is the default local for system applications.\n\n2\n\nCreate the Desktop directory and make sure jovyan can put files there. This is mainly for debugging.\n\n3\n\nSet up the default XDG_DESKTOP_DIR value. This will be copied to the ~.config (by xinitrc).\n\n4\n\nCopy the .desktop file in the Desktop directory into the applications directory and make a symlink to the Desktop directory. The former means that the applications will appear in the menu in xfce4 desktop and the latter means there will be a desktop icon.\n\n5\n\nAdd any mime xml files to the mime folder and update the mime database.\n\n6\n\nAdd any png or svg icon files to the icon folder and update the icon database.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Developer notes</span>"
    ]
  },
  {
    "objectID": "related.html",
    "href": "related.html",
    "title": "8  Related Docker Stacks",
    "section": "",
    "text": "NASA Openscapes corn and NASA Openscapes py-rocket\nRocker R docker stack\nPangeo geosciences docker stack\nJupyter data science docker stack\ngeocompx\nb-data GPU accelerated docker images and devcontainers",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Related Docker Stacks</span>"
    ]
  }
]